# 如何写性能更高的代码

可靠性，可用性，可维护性

可用性：如果你的程序太卡，其实就是可用性差。
可维护性：可读，可扩展。

1、如果做v2map这样的一个地图？框架级的简单设计思路。

基于面向对象的设计方法。

a、地图对象
b、地图的各层对象
c、地图的具体区块
e、动画

![](v2map组件分层.png)

第一步，根据“常识中”的事物的关系，创建出各个类，并且串联他们的继承关系，和包含关系。
第二步，补全各个类（对象）的基本特性。
第三步，提供一个框架的配置和启动器，开始测试。

2、关于程序的性能问题
O(n^3)，这是一个性能很差的算法。
O(nlogn)，这是通常而言的优化目标。

O描述的是随着输入规模增长的“单元执行时长”的增长趋势。

1、什么的是单元执行时长。
也就是不可拆分的，一定会消耗的必要时长。n/2的时长就是一个单元时长。
在对性能要求极端的情况下，我们要提升的就包含单元时长，例子：n>>1的性能，比n/2要高。

2、程序性能优化的本质。
减少执行的次数。执行：本质是指令。
二八定理，80%的工作都是同一个工作。80%的性能会消耗在20%的模块里。

这是一个O(n^3)的例子：
for(n){
for(n){
for(n){
//单元执行

不要评价算法的时间复杂度，直接评价它的执行次数。
做个假设：
n=3，单元的执行的内容是普通的加法，视为O(1)。
结论：
27次执行，毫无优化的必要。

这是一个O(n)的例子：
for(n){
Array.sort();
}
它的实际复杂度，是 O(n^2 * logn)。
换言之，如果N特别大，那么呢，它非常的损耗性能。
结论是：
有必要做优化。

再来一个O(n)的例子：
一个paint()函数，其时间复杂度为 O(n)。
60fps的动画/游戏，一定会在1s内执行60次paint()。
16ms内，要执行完一次paint，不然，会卡顿。
结论是：
有必要做优化。

3、关于内存
1、循环，比递归要好。
所有的代码都是有作用域的，在作用域内的变量，会在作用域结束时候被释放。
作用域的最小单位：{}。
{
int i=1;//这个i是会占用内存的
}//执行到这个括号后，i就被释放了。

一个递归的例子：
a(){
//在某个时刻退出
int i=1;

任何的递归，都可以用循环来替代。
一个典型的内存溢出图形：

![](递归循环.png)


2、过多的对象累积，但是没有主动释放，由于程序的执行时长过长，导致内存崩溃。

一般程序要求7x24小时稳定运行。
为什么会稳定不了呢？

一个对象基本是有自己的生命周期的，在C++里，类的创建，是有构造函数，和析构函数的。而Java、js，只提供了构造。这是垃圾回收的功能。

典型的例子：
观察者模式，也就是监听。
Listener，监听者负责观察被监听者的特定动态，当被监听者发生对应动作时，监听者会得到通知。
通常的实现是，提供一个列表，里面维护了所有的观察者，被观察者负责添加观察者。
例子：
a.addListener('click/propChanged',(e)=>{
//dosomething
e.target//一般呢，会有target这种对象存在，维护了被观察者的引用。这会导致，无法回收。
})
问题出在，如果被观察者，消亡了呢？
观察者如果不知情，会一直观察它。

所以，原则：如果一个对象添加了监听，在该对象被移除的时候，一定要主动写代码，销毁监听。

4、一个具体的优化的实例——缓存
空间换时间。
js：object。
java：hashMap。
key-value结构，经常可以用来做缓存。

理论上，key-value的最常见的读取时间复杂度是O(1)。

一般的优化场景，把O(n^2）的多层循环，解开，变成两个乃至多个O(n)的循环。
思维误区：代码是越短性能越高？错误。

举例：
我有一个配置单，是数组的形式。
我需要结合配置单和生产数据，产生我需要的最终数据。
一般情况下代码是：
//如果配置单很庞大，那么，下面代码性能就很差
//O(n*m)
for(生产数据){
for(配置单){
配置单结合生产数据

步骤：
一、一次循环解析出一张映射表（hashMap\object）
二、一次循环把需要匹配的内容，和映射表进行匹配

优化代码1：
//O(n)
for(配置单){
cacheMap.push(key,value);//产生一个缓存表
}
//O(m)
for(生产数据){
cacheMap.get(key)//使用缓存进行管理

优化代码2：
//首次执行O(n)，未来的执行是O(1)
if(!cacheMap){
for(配置单){
cacheMap.push(key,value);//产生一个缓存表

//O(m)
for(生产数据){
cacheMap.get(key)//使用缓存进行管理
}
